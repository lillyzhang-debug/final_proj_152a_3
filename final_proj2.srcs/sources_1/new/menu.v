// handles the game state and the LED display
module game_controller (
    input ms_clock, // flash leds @ certain intervals of this
    input start, // reset/start button, maybe done outside
    input [1:0] keypad,
    input [2:0] sw,
    input [1:0] LED_2_disp, // random LED generated by random_num_gen
    // ouput to phys board
    output reg [3:0] ones,
    output reg [3:0] tens,
    output reg [3:0] hundreds,
    output reg [3:0] thousands,
    output reg [3:0] sec,
    output reg [3:0] ten_sec,
    output reg [3:0] LED_on
    );
    
    wire [1:0] game_mode;
    wire [13:0] score;
    
    wire playing;
    
 
 game_fsm (
    .clk(ms_clock),
    .reset(start),
    .sw(sw)
    );

led_controller (
    .clk(ms_clock),
    .random_led_in(LED_2_disp),
    .keypad(keypad),
    .game_mode(game_mode),
    .sw(sw)
    );
   
display_info (
    .clk(ms_clock),
    // from display_parser in score_tabulator.v
    .ones_score(ones),
    .tens_score(tens),
    .hundreds_score(hundreds),
    .thousands_score(thousands),
    .seconds(sec),
    .ten_seconds(ten_sec),
    // from game_fsm
    .game_mode(game_mode),
    .playing(playing)
    );
    
 endmodule
 
 // used to control the current state of the game
 // & perform any relevant setup tasks for each respective state
 module game_fsm(
    input clk,
    input reset,
    input [2:0] sw,
    output reg playing, // either actively playing the game (PLAYING) or not playing (IDLE/STARTUP) MAY NOT BE USED
    output reg [15:0] timer, // current timer status
    output reg [1:0] game_mode, // may not be used?
    output reg generate_nums
    );
    
    //states
    localparam IDLE = 0; // display final score and wait for reset -> enter startup
    localparam STARTUP = 1; // flash duration (if valid input) or final score (invalid game mode) 3 times 
    // if valid -> PLAYING
    // if invalid -> IDLE
    localparam PLAYING = 2; // run game until duration ends, when duration ends, enter IDLE mode
    
    reg [2:0] current_state = IDLE;
    reg [15:0] timer; // general purpose
    reg [15:0] countdown;
    reg [15:0] duration;
    reg started = 0; // mark started if the correct game mode input is given
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin// whenever we hit the reset button, attempt to start the game NOTE THIS MAY FUNCTION INCORRECTLY
            current_state <= STARTUP;
            game_mode <= 1;
            playing <= 0;
            timer <= 0;
        end else begin
            case (current_state) 
                IDLE: begin 
                    playing <= 0;
                    generate_nums <= 0;
                    // check sw to set game mode
                    // if more than one sw is flipped, just flash final score and return mode to 0
                    if (sw[0] == 1 && sw[1] == 0 && sw[2] == 0) begin
                        duration <= 10000; // 10 s
                        started <= 1;
                    end
                    if (sw[0] == 0 && sw[1] == 1 && sw[2] == 0) begin
                        duration <= 20000; // 20s
                        started <= 1;
                    end
                    if (sw[0] == 0 && sw[1] == 1 && sw[2] == 0) begin
                        duration <= 30000; //30 s
                        started <= 1;
                    end
                    current_state <= STARTUP; // transition to startup mode
                    game_mode <= 1;
                 end
                 STARTUP: begin
                    playing <= 0;
                    generate_nums <= 0;
                    timer <= timer + 1;
                    if (timer >= 3000) begin
                        timer <= 0;
                        if (started == 1) begin
                            current_state <= PLAYING; // only transition to PLAYING if started is correctly set
                            game_mode <= 2;
                        end else 
                            current_state <= IDLE;
                            game_mode <= 0;
                    end
                 end
                 PLAYING: begin
                    playing <= 1;
                    generate_nums <= 1;
                    timer <= timer + 1;
                    countdown <= countdown - 1;
                    if (timer >= duration) begin
                        playing <= 0;
                        current_state <= IDLE;
                        game_mode <= 0;
                        started <= 0; // reset
                    end
                end
            endcase       
        end
     end
endmodule

// takes in game mode from game_fsm
// if game mode is on, controls what led needs to flash and for how long
// takes user input and turns LED off when correct button is pressed
// if game mode is off, simply display the final score from the last played game
module led_controller (
    input clk,
    input [1:0] random_led_in,
    input [1:0] keypad,
    input [1:0] game_mode,
    output reg [3:0] led_2_disp,
    output reg [10:0] diff, // new addition, export the time taken for user to respond 
    output reg user_hit
    );
    
    reg [10:0] flash_timer;
    reg [1:0] target_led;
    
    always @(posedge clk) begin
        user_hit <= 0; // always default to user did not hit 
        if (game_mode == 2'b00 || game_mode == 2'b01) begin
            // not playing, set the flash_timer back to 0, and only display the old score
            flash_timer <= 0;
            
        end else if(game_mode == 2'b10) begin // game_mode == PLAYING == 2
            flash_timer <= flash_timer + 1;
            // if we've reached .8 ms increment, flash a random LED and turn all others off no matter what
            if (flash_timer  >= 800) begin
                // check which rand LED is to be flashed
                // set it to on until the user presses or time runs out
                flash_timer <= 0;
                target_led <= random_led_in;
                // use one-hot encoding to export random led to display
                led_2_disp <= 0;
                led_2_disp[target_led] <= 1;
            end
            // check if the user has pressed the right button
            // if so turn the flashed LED off
                if (keypad == target_led && led_2_disp[target_led] == 1) begin
                    diff <= flash_timer; // save the current status of the timer and export to score tabulation
                    led_2_disp[target_led] <= 0;
                    user_hit <= 1;
                end
            end
        end
endmodule

module display_info (
    input clk,
    // input final score
    input [3:0] ones_score,
    input [3:0] tens_score,
    input [3:0] hundreds_score,
    input [3:0] thousands_score,
    // input remaining time/time setting
    input [3:0] seconds,
    input [3:0] ten_seconds,
    // game_mode -> what game state, playing -> are we actually playing the game now
    input [1:0] game_mode,
    input playing,
    // use these in each mode to send value to display
    output reg [3:0] ones, 
    output reg [2:0] tens, 
    output reg [3:0] hundreds, 
    output reg [2:0] thousands
    );
   
    always @(posedge clk) begin
        case (game_mode)
            0: begin // idle
                ones <= ones_score;
                tens <= tens_score;
                hundreds <= hundreds_score;
                thousands <= thousands_score;
            end
            1: begin // startup
                if (playing) begin
                    ones <= seconds;
                    tens <= ten_seconds;
                    hundreds <= 0;
                    thousands <= 0;
                end else begin
                    ones <= ones_score;
                    tens <= tens_score;
                    hundreds <= hundreds_score;
                    thousands <= thousands_score;
               end
             end
             2: begin // game
                 ones <= seconds;
                 tens <= ten_seconds;
                 hundreds <= 0;
                 thousands <= 0;
             end
         endcase
     end
endmodule
    

