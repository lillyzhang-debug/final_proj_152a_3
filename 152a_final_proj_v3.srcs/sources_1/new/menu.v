// handles the game state and the LED display
module game_controller (
    input ms_clock, // flash leds @ certain intervals of this
    input start, // reset/start button, maybe done outside
    input [3:0] keypad,
    input [2:0] sw,
    input [1:0] LED_2_disp, // random LED generated by random_num_gen
    
    // ouput to phys board
    output [3:0] ones,
    output [3:0] tens,
    output [3:0] hundreds,
    output [3:0] thousands,
   
    output [3:0] LED_on,
    output [10:8] LED_on_2, // for debug
//    output started_debug
    );
    
    wire [1:0] game_mode;
//    wire generate_nums;
    wire [13:0] score;

//    wire [15:0] countdown;
    
    wire playing;
    wire started;
    wire user_hit;
    
    wire [10:0] response_diff;
    
//    assign started_debug = started;
 
 game_fsm mod_gfsm (
    .clk(ms_clock),
    .reset(start),
    .sw(sw),
    //OUTPUTS
    .playing(playing), 
    .started(started),  
    .countdown(countdown),
    .game_mode(game_mode), 
    .generate_nums(generate_nums)
    );

led_controller mod_ledc (
    .clk(ms_clock),
    .random_led_in(LED_2_disp),
    .keypad(keypad),
    .game_mode(game_mode),
    // Outputs
    .led_2_disp(LED_on),       // <--- Connects to top-level output port
    .debug_led(LED_on_2),
    .diff(response_diff),      // <--- Captured in wire (send to score tabulator later)
    .user_hit(user_hit_w)      // <--- Captured in wire
    );
    wire [3:0] ones_score;
    wire [3:0] tens_score;
    wire [3:0] hundreds_score;
    wire [3:0] thousands_score;
    wire [3:0] sec;
    wire [3:0] ten_sec;
    
//this outputs parsed time and score    
score_top_module mod4(
    .clk(ms_clock),
//  .game_mode(game_mode),
    .reset(start),
    .user_hit(user_hit_w),
    .reaction_time(response_diff),
    .countdown(countdown),
    //OUTPUTS
    .ones(ones_score), 
    .tens(tens_score), 
    .hundreds(hundreds_score), 
    .thousands(thousands_score),
    .sec(sec),
    .ten_sec(ten_sec)
);

//this decides whether display show show score or time
display_info mode_di (
    .clk(ms_clock),
    // from display_parser in score_tabulator.v
    .ones_score(ones_score),
    .tens_score(tens_score),
    .hundreds_score(hundreds_score),
    .thousands_score(thousands_score),
    .seconds(sec),
    .ten_seconds(ten_sec),
    // from game_fsm
    .game_mode(game_mode),
    .started(started),
    // Outputs (To Physical Board Pins)
    .ones(ones),           // <--- Connected to top-level output
    .tens(tens),
    .hundreds(hundreds),
    .thousands(thousands)
    );
    
endmodule
 
 // used to control the current state of the game
 // & perform any relevant setup tasks for each respective state
 module game_fsm(
    input clk,
    input reset,
    input [2:0] sw,
    output reg playing, // either actively playing the game (PLAYING) or not playing (IDLE/STARTUP) MAY NOT BE USED
    output reg started,
    output reg [15:0] timer, // current timer status
    output reg [15:0] countdown, //current clock time
    output reg [1:0] game_mode, // may not be used?
    output reg generate_nums
    );
    
    //states
    localparam IDLE = 0; // display final score and wait for reset -> enter startup
    localparam STARTUP = 1; // flash duration (if valid input) or final score (invalid game mode) 3 times 
    // if valid -> PLAYING
    // if invalid -> IDLE
    localparam PLAYING = 2; // run game until duration ends, when duration ends, enter IDLE mode
    
    reg [2:0] current_state = IDLE;
    // reg [15:0] timer; // general purpose
//    reg [15:0] countdown;
    reg [15:0] duration;
    reg started;
    initial begin
        started = 0; // mark started if the correct game mode input is given
    end
    
    always @(posedge clk or posedge reset) begin
        if (reset) begin// whenever we hit the reset button, attempt to start the game NOTE THIS MAY FUNCTION INCORRECTLY
            playing <= 0;
            timer <= 0;
            started <= 0;
            // check sw to set game mode
            // if more than one sw is flipped, just flash final score and return mode to 0
            if (sw[0] == 1 && sw[1] == 0 && sw[2] == 0) begin
                duration <= 10000; // 10 s
                started <= 1;
                current_state <= STARTUP; // transition to startup mode
                countdown <= 3000;
                game_mode <= 1;
            end
            else if (sw[0] == 0 && sw[1] == 1 && sw[2] == 0) begin
                duration <= 20000; // 20s
                started <= 1;
                current_state <= STARTUP; // transition to startup mode
                countdown <= 3000;
                game_mode <= 1;
            end
            else if (sw[0] == 0 && sw[1] == 0 && sw[2] == 1) begin
                duration <= 30000; //30 s
                started <= 1;
                current_state <= STARTUP; // transition to startup mode
                countdown <= 3000;
                game_mode <= 1;
            end else begin
                started <= 0;
                current_state <= STARTUP; // transition to startup mode
                countdown <= 3000;
                game_mode <= 1;
            end
            
        end else begin
            case (current_state) 
                IDLE: begin 
                    playing <= 0;
                    generate_nums <= 0;
                    game_mode <= 0;
                    timer <= 0;
                 end
                
                 STARTUP: begin
                    playing <= 0;
                    generate_nums <= 0;
                    timer <= timer + 1;
                    countdown <= countdown - 1;
                    if (timer >= 3000) begin
                        timer <= 0;
                        if (started == 1) begin
                            current_state <= PLAYING; // only transition to PLAYING if started is correctly set
                            game_mode <= 2;
                            countdown <= duration; //begin the countdown at max time
                        end else begin
                            current_state <= IDLE;
                            game_mode <= 0;
                        end
                    end
                 end
                
                 PLAYING: begin
                    playing <= 1;
                    generate_nums <= 1;
                    timer <= timer + 1;
                    countdown <= countdown - 1;
                    if (timer >= duration) begin
                        playing <= 0;
                        current_state <= IDLE;
                        game_mode <= 0;
                        started <= 0; // reset
                    end
                end
                
            endcase       
        end
     end
endmodule

// takes in game mode from game_fsm
// if game mode is on, controls what led needs to flash and for how long
// takes user input and turns LED off when correct button is pressed
// if game mode is off, simply display the final score from the last played game
module led_controller (
    input clk,
    input [1:0] random_led_in,
    input [3:0] keypad,
    input [1:0] game_mode,
    output reg [3:0] led_2_disp,
    output reg [10:8] debug_led,
    output reg [10:0] diff, // new addition, export the time taken for user to respond 
    output reg user_hit
    );
    
    reg [10:0] flash_timer;
    reg [1:0] target_led;
    
    always @(posedge clk) begin
        user_hit <= 0; // always default to user did not hit 
        if (game_mode == 2'b00 || game_mode == 2'b01) begin
            // not playing, set the flash_timer back to 0, and only display the old score
            flash_timer <= 0;
            led_2_disp <= 4'b1111;
            
        end else if(game_mode == 2'b10) begin // game_mode == PLAYING == 2
            flash_timer <= flash_timer + 1;
            // if we've reached 2.5 s increment, flash a random LED and turn all others off no matter what
            if (flash_timer  >= 1000) begin
                // check which rand LED is to be flashed
                // set it to on until the user presses or time runs out
                flash_timer <= 0;
                target_led <= random_led_in;
                // use one-hot encoding to export random led to display
                led_2_disp <= 4'b0000;
                led_2_disp[random_led_in] <= 1'b1;
            end
            // check if the user has pressed the right button
            // if so turn the flashed LED off
                if (keypad[target_led] == 1'b1 && led_2_disp[target_led] == 1'b1) begin
                    diff <= flash_timer; // save the current status of the timer and export to score tabulation
                    led_2_disp[target_led] <= 0;
                    user_hit <= 1;
                end
            end
            
            if(game_mode == 2'b00) begin
                debug_led <= 3'b100;
            end else if(game_mode  == 2'b01) begin
                debug_led <= 3'b010;
            end else if(game_mode == 2'b10) begin
                debug_led <= 3'b001;
            end
        end
endmodule

module display_info (
    input clk,
    // input final score
    input [3:0] ones_score,
    input [3:0] tens_score,
    input [3:0] hundreds_score,
    input [3:0] thousands_score,
    // input remaining time/time setting
    input [3:0] seconds,
    input [3:0] ten_seconds,
    // game_mode -> what game state, playing -> are we actually playing the game now
    input [1:0] game_mode,
    input started,
    // use these in each mode to send value to display
    output reg [3:0] ones, 
    output reg [2:0] tens, 
    output reg [3:0] hundreds, 
    output reg [2:0] thousands
    );
   
    always @(posedge clk) begin
        case (game_mode)
            0: begin // idle
                ones <= ones_score;
                tens <= tens_score;
                hundreds <= hundreds_score;
                thousands <= thousands_score;
            end
            1: begin // startup
                if (started) begin
                    ones <= seconds;
                    tens <= ten_seconds;
                    hundreds <= 0;
                    thousands <= 0;
                end else begin
                    ones <= ones_score;
                    tens <= tens_score;
                    hundreds <= hundreds_score;
                    thousands <= thousands_score;
               end
             end
             2: begin // game
                 ones <= seconds;
                 tens <= ten_seconds;
                 hundreds <= 0;
                 thousands <= 0;
             end
         endcase
     end
endmodule
    

